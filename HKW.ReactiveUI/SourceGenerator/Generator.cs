// Source from https://github.com/SparkyTD/ReactiveCommand.SourceGenerator

using System.CodeDom.Compiler;
using HKW.HKWReactiveUI.Extensions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace HKW.HKWReactiveUI.SourceGenerator;

[Generator]
internal class Generator : ISourceGenerator
{
    public Generator() { }

    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        var extensionInfos = ExtractMethodExtensionInfos(context.Compilation);
        foreach (var classExtensionInfo in extensionInfos)
        {
            var stringStream = new StringWriter();
            var writer = new IndentedTextWriter(stringStream, "\t");
            writer.WriteLine("// <auto-generated>");
            writer.WriteLine($"namespace {classExtensionInfo.ClassNamespace}");
            writer.WriteLine("{");
            writer.Indent++;
            bool isAbstract = classExtensionInfo.DeclarationSyntax.Modifiers.Any(
                SyntaxKind.AbstractKeyword
            );
            var accessibility = classExtensionInfo.DeclarationSyntax.Modifiers.FirstOrDefault(m =>
                m.Kind() == SyntaxKind.PublicKeyword
                || m.Kind() == SyntaxKind.InternalKeyword
                || m.Kind() == SyntaxKind.PrivateKeyword
            );
            writer.WriteLine(
                $"{accessibility}{(isAbstract ? SyntaxKind.AbstractKeyword : null)} partial class {classExtensionInfo.ClassName}"
            );
            writer.WriteLine($"{classExtensionInfo.DeclarationSyntax.TypeParameterList}");
            writer.WriteLine($"{classExtensionInfo.DeclarationSyntax.ConstraintClauses}");
            writer.WriteLine("{");
            writer.Indent++;
            foreach (var commandExtensionInfo in classExtensionInfo.CommandExtensionInfos)
            {
                var outputType = commandExtensionInfo.GetOutputTypeText();
                var inputType = commandExtensionInfo.GetInputTypeText();
                writer.WriteLine(
                    $"public ReactiveUI.ReactiveCommand<{inputType}, {outputType}> "
                        + $"{commandExtensionInfo.MethodName}Command {{ get; private set; }}"
                );
                //var commandName = $"{commandExtensionInfo.MethodName}Command";
                //if (
                //    commandExtensionInfo.ReactiveCommandDatas.FindIndex(d =>
                //        d.Name == nameof(ReactiveCommandAttribute.CanExecute)
                //    ) != -1
                //)
                //{
                //    writer.WriteLine($"protected bool {commandName}CanExecute {{ get; set; }}");
                //}
            }

            writer.WriteLine();
            if (classExtensionInfo.IsReactiveObjectXDerivedClass)
            {
                writer.WriteLine("protected override void InitializeCommands()");
            }
            else
            {
                writer.WriteLine("protected void InitializeCommands()");
            }
            writer.WriteLine("{");
            writer.Indent++;
            foreach (var commandExtensionInfo in classExtensionInfo.CommandExtensionInfos)
            {
                var commandName = $"{commandExtensionInfo.MethodName}Command";
                var outputType = commandExtensionInfo.GetOutputTypeText();
                var inputType = commandExtensionInfo.GetInputTypeText();

                writer.Write($"{commandName} = ReactiveUI.ReactiveCommand.");
                // 检测异步和参数
                if (commandExtensionInfo.ArgumentType is null)
                {
                    writer.Write(
                        commandExtensionInfo.IsTask is false
                            ? $"Create({commandExtensionInfo.MethodName}"
                            : $"CreateFromTask({commandExtensionInfo.MethodName}"
                    );
                }
                else if (commandExtensionInfo.MethodReturnType is not null)
                {
                    writer.Write(
                        commandExtensionInfo.IsTask is false
                            ? $"Create<{inputType}, {outputType}>({commandExtensionInfo.MethodName}"
                            : $"CreateFromTask<{inputType}, {outputType}>({commandExtensionInfo.MethodName}"
                    );
                }
                else if (commandExtensionInfo.MethodReturnType is null)
                {
                    writer.Write(
                        commandExtensionInfo.IsTask is false
                            ? $"Create<{inputType}>({commandExtensionInfo.MethodName}"
                            : $"CreateFromTask<{inputType}>({commandExtensionInfo.MethodName}"
                    );
                }
                if (
                    commandExtensionInfo.ReactiveCommandDatas.FirstOrDefault(d =>
                        d.Name == nameof(ReactiveCommandAttribute.CanExecute)
                    )
                    is NameTypeAndValue reactiveCommandData
                )
                {
                    writer.WriteLine(
                        $", DynamicData.Binding.NotifyPropertyChangedEx.WhenValueChanged(this, x => x.{reactiveCommandData.Value}));"
                    );
                }
                else
                    writer.WriteLine(");");
            }

            writer.Indent--;
            writer.WriteLine("}");

            writer.Indent--;
            writer.WriteLine("}");
            writer.Indent--;
            writer.WriteLine("}");

            context.AddSource(
                $"{classExtensionInfo.ClassName}.ReactiveCommand.g.cs",
                stringStream.ToString()
            );
            Console.Out.WriteLine(stringStream);
        }
    }

    private static IEnumerable<ClassExtensionInfo> ExtractMethodExtensionInfos(
        Compilation compilation
    )
    {
        foreach (var compilationSyntaxTree in compilation.SyntaxTrees)
        {
            var semanticModel = compilation.GetSemanticModel(compilationSyntaxTree);
            var declaredClasses = compilationSyntaxTree
                .GetRoot()
                .DescendantNodesAndSelf()
                .OfType<ClassDeclarationSyntax>();
            // 解析类
            foreach (var declaredClass in declaredClasses)
            {
                // 如果不是分布类型,则跳过
                if (declaredClass.Modifiers.Any(SyntaxKind.PartialKeyword) is false)
                    continue;

                var classSymbol = (INamedTypeSymbol)
                    ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;

                var classNamespace = classSymbol.ContainingNamespace.ToString();
                var typeName = declaredClass.Identifier.ValueText;

                var classExtensionInfo = new ClassExtensionInfo
                {
                    ClassName = typeName,
                    ClassNamespace = classNamespace,
                    DeclarationSyntax = declaredClass,
                };
                if (classSymbol.AnyBaseTypeIs("HKW.HKWReactiveUI.ReactiveObjectX"))
                    classExtensionInfo.IsReactiveObjectXDerivedClass = true;

                // 解析方法
                var methodMembers = declaredClass.Members.OfType<MethodDeclarationSyntax>();
                foreach (var methodSyntax in methodMembers)
                {
                    var methodSymbol = (IMethodSymbol)
                        ModelExtensions.GetDeclaredSymbol(semanticModel, methodSyntax)!;
                    // 参数太多,跳过
                    if (methodSymbol.Parameters.Length > 1)
                        continue;
                    // 获取特性数据
                    var attributeData = methodSymbol
                        .GetAttributes()
                        .FirstOrDefault(a =>
                            a.AttributeClass?.Name == nameof(ReactiveCommandAttribute)
                        );
                    if (attributeData is null)
                        continue;
                    // 获取特性的参数

                    var reactiveCommandDatas = new List<ReactiveCommandData>();
                    if (attributeData.TryGetAttributeAndValues(out var values))
                    {
                        // 删除空的CanExecute
                        var index = values.FindIndex(v =>
                            v.Name == nameof(ReactiveCommandAttribute.CanExecute)
                            && string.IsNullOrWhiteSpace(v.Value.ToString())
                        );
                        if (index != -1)
                            values.RemoveAt(index);
                    }

                    // 是否为异步方法
                    bool isTask = IsTaskReturnType(methodSymbol.ReturnType);
                    var realReturnType = isTask
                        ? GetTaskReturnType(compilation, methodSymbol.ReturnType)
                        : methodSymbol.ReturnType;
                    // 是否为空返回值
                    var isReturnTypeVoid = SymbolEqualityComparer.Default.Equals(
                        realReturnType,
                        compilation.GetSpecialType(SpecialType.System_Void)
                    );

                    classExtensionInfo.CommandExtensionInfos.Add(
                        new()
                        {
                            MethodName = methodSymbol.Name,
                            MethodReturnType = isReturnTypeVoid ? null : realReturnType,
                            IsTask = isTask,
                            ArgumentType = methodSymbol.Parameters.SingleOrDefault()?.Type,
                            ReactiveCommandDatas = values
                        }
                    );
                }

                if (classExtensionInfo.CommandExtensionInfos.Any())
                    yield return classExtensionInfo;
            }
        }
    }

    private static ITypeSymbol GetTaskReturnType(Compilation compilation, ITypeSymbol typeSymbol)
    {
        if (typeSymbol is INamedTypeSymbol { TypeArguments.Length: 1 } namedTypeSymbol)
            return namedTypeSymbol.TypeArguments[0];
        return compilation.GetSpecialType(SpecialType.System_Void);
    }

    private static bool IsTaskReturnType(ITypeSymbol typeSymbol)
    {
        var nameFormat = SymbolDisplayFormat.FullyQualifiedFormat;
        do
        {
            var typeName = typeSymbol?.ToDisplayString(nameFormat);
            if (typeName == "global::System.Threading.Tasks.Task")
                return true;

            typeSymbol = typeSymbol?.BaseType;
        } while (typeSymbol is not null);

        return false;
    }
}

public class ReactiveCommandData(NameTypeAndValue nameTypeAndValue, string canExecutePropertyName)
{
    /// <summary>
    /// 名称和值
    /// </summary>
    public NameTypeAndValue NameTypeAndValue { get; } = nameTypeAndValue;
}
