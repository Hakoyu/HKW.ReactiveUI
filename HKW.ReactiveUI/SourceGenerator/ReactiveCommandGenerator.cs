// Source from https://github.com/SparkyTD/ReactiveCommand.SourceGenerator

using System.CodeDom.Compiler;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace HKW.HKWReactiveUI.SourceGenerator;

internal static class ReactiveCommandGenerator
{
    public static void Execute(GeneratorExecutionContext context)
    {
        foreach (var compilationSyntaxTree in context.Compilation.SyntaxTrees)
        {
            var semanticModel = context.Compilation.GetSemanticModel(compilationSyntaxTree);
            var declaredClasses = compilationSyntaxTree
                .GetRoot()
                .DescendantNodesAndSelf()
                .OfType<ClassDeclarationSyntax>();
            // 解析类
            foreach (var declaredClass in declaredClasses)
            {
                if (Check(semanticModel, declaredClass, out var classExtensionInfo) is false)
                    continue;

                Parse(context.Compilation, semanticModel, declaredClass, classExtensionInfo);

                Generator(context, classExtensionInfo);
            }
        }
    }

    private static bool Check(
        SemanticModel semanticModel,
        ClassDeclarationSyntax declaredClass,
        out ClassExtensionInfo classExtensionInfo
    )
    {
        classExtensionInfo = null!;
        // 如果不是分布类型,则跳过
        if (declaredClass.Modifiers.Any(SyntaxKind.PartialKeyword) is false)
            return false;

        var classSymbol = (INamedTypeSymbol)
            ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;

        var classNamespace = classSymbol.ContainingNamespace.ToString();
        var typeName = declaredClass.Identifier.ValueText;

        classExtensionInfo = new ClassExtensionInfo
        {
            ClassName = typeName,
            ClassNamespace = classNamespace,
            DeclarationSyntax = declaredClass,
        };

        // 如果不是ReactiveObject的派生类,则跳过
        if (classSymbol.AnyBaseTypeIs(NativeData.ReactiveObjectFullName) is false)
            return false;
        return true;
    }

    private static void Parse(
        Compilation compilation,
        SemanticModel semanticModel,
        ClassDeclarationSyntax declaredClass,
        ClassExtensionInfo classExtensionInfo
    )
    {
        // 解析方法
        var methodMembers = declaredClass.Members.OfType<MethodDeclarationSyntax>();
        foreach (var methodSyntax in methodMembers)
        {
            var methodSymbol = (IMethodSymbol)
                ModelExtensions.GetDeclaredSymbol(semanticModel, methodSyntax)!;
            // 参数太多,跳过
            if (methodSymbol.Parameters.Length > 1)
                continue;
            // 获取特性数据
            var attributeData = methodSymbol
                .GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == nameof(ReactiveCommandAttribute));
            if (attributeData is null)
                continue;
            // 获取特性的参数
            if (attributeData.TryGetAttributeAndValues(out var values))
            {
                // 删除空的CanExecute
                var index = values.FindIndex(v =>
                    v.Name == nameof(ReactiveCommandAttribute.CanExecute)
                    && string.IsNullOrWhiteSpace(v.Value.ToString())
                );
                if (index != -1)
                    values.RemoveAt(index);
            }

            // 是否为异步方法
            bool isTask = methodSymbol.ReturnType.AnyBaseTypeIs(
                NativeData.TaskTypeFullName,
                SymbolDisplayFormat.FullyQualifiedFormat
            );
            var realReturnType = isTask
                ? compilation.GetTaskReturnType(methodSymbol.ReturnType)
                : methodSymbol.ReturnType;
            // 是否为空返回值
            var isReturnTypeVoid = compilation.IsVoid(realReturnType);

            classExtensionInfo.CommandExtensionInfos.Add(
                new()
                {
                    MethodName = methodSymbol.Name,
                    MethodReturnType = isReturnTypeVoid ? null : realReturnType,
                    IsTask = isTask,
                    ArgumentType = methodSymbol.Parameters.SingleOrDefault()?.Type,
                    ReactiveCommandDatas = values
                }
            );
        }
    }

    private static void Generator(
        GeneratorExecutionContext context,
        ClassExtensionInfo classExtensionInfo
    )
    {
        var stringStream = new StringWriter();
        var writer = new IndentedTextWriter(stringStream, "\t");
        writer.WriteLine("// <auto-generated>");
        writer.WriteLine($"namespace {classExtensionInfo.ClassNamespace}");
        writer.WriteLine("{");
        writer.Indent++;
        bool isAbstract = classExtensionInfo.DeclarationSyntax.Modifiers.Any(
            SyntaxKind.AbstractKeyword
        );
        var accessibility = classExtensionInfo.DeclarationSyntax.Modifiers.GetAccessibility();
        writer.WriteLine(
            $"{accessibility}{(isAbstract ? SyntaxKind.AbstractKeyword : null)} partial class {classExtensionInfo.ClassName}"
        );
        writer.WriteLine($"{classExtensionInfo.DeclarationSyntax.TypeParameterList}");
        writer.WriteLine($"{classExtensionInfo.DeclarationSyntax.ConstraintClauses}");
        writer.WriteLine("{");
        writer.Indent++;

        GeneratorReactiveCommandProperty(classExtensionInfo, writer);

        writer.Indent--;
        writer.WriteLine("}");
        writer.Indent--;
        writer.WriteLine("}");

        context.AddSource(
            $"{classExtensionInfo.ClassName}.ReactiveCommand.g.cs",
            stringStream.ToString()
        );
        Console.Out.WriteLine(stringStream);

        static void GeneratorReactiveCommandProperty(
            ClassExtensionInfo classExtensionInfo,
            IndentedTextWriter writer
        )
        {
            foreach (var commandExtensionInfo in classExtensionInfo.CommandExtensionInfos)
            {
                var outputType = commandExtensionInfo.GetOutputTypeText();
                var inputType = commandExtensionInfo.GetInputTypeText();
                var fieldName = $"_{commandExtensionInfo.MethodName.FirstLetterToLower()}Command";
                var propretyName = $"{commandExtensionInfo.MethodName}Command";
                // 添加DebuggerBrowsable,防止调试器显示
                writer.WriteLine(
                    "[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)]"
                );
                // 添加ReactiveCommand字段
                writer.WriteLine(
                    $"private ReactiveUI.ReactiveCommand<{inputType}, {outputType}> "
                        + $"{fieldName};"
                );
                // 添加ReactiveCommand属性
                writer.WriteLine(
                    $"public ReactiveUI.ReactiveCommand<{inputType}, {outputType}> "
                        + $"{propretyName} => "
                );
                writer.Write($"{fieldName} ?? ({fieldName} = ");
                writer.Write($"ReactiveUI.ReactiveCommand.");
                // 检测异步和参数
                if (commandExtensionInfo.ArgumentType is null)
                {
                    writer.Write(
                        commandExtensionInfo.IsTask is false
                            ? $"Create({commandExtensionInfo.MethodName}"
                            : $"CreateFromTask({commandExtensionInfo.MethodName}"
                    );
                }
                else if (commandExtensionInfo.MethodReturnType is not null)
                {
                    writer.Write(
                        commandExtensionInfo.IsTask is false
                            ? $"Create<{inputType}, {outputType}>({commandExtensionInfo.MethodName}"
                            : $"CreateFromTask<{inputType}, {outputType}>({commandExtensionInfo.MethodName}"
                    );
                }
                else if (commandExtensionInfo.MethodReturnType is null)
                {
                    writer.Write(
                        commandExtensionInfo.IsTask is false
                            ? $"Create<{inputType}>({commandExtensionInfo.MethodName}"
                            : $"CreateFromTask<{inputType}>({commandExtensionInfo.MethodName}"
                    );
                }
                // 如果有CanExecute则添加canExecute参数
                if (
                    commandExtensionInfo.ReactiveCommandDatas.FirstOrDefault(d =>
                        d.Name == nameof(ReactiveCommandAttribute.CanExecute)
                    )
                    is NameTypeAndValue reactiveCommandData
                )
                {
                    writer.Write(
                        $", DynamicData.Binding.NotifyPropertyChangedEx.WhenValueChanged(this, x => x.{reactiveCommandData.Value})"
                    );
                }
                writer.WriteLine("));");
                writer.WriteLine();
            }
        }
    }
}
