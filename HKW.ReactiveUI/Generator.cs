// Source from https://github.com/SparkyTD/ReactiveCommand.SourceGenerator

using System.CodeDom.Compiler;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace HKW.HKWReactiveUI.SourceGenerator;

[Generator]
public class Generator : ISourceGenerator
{
    public Generator() { }

    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        var extensionInfos = ExtractMethodExtensionInfos(context.Compilation);
        foreach (var classExtensionInfo in extensionInfos)
        {
            var stringStream = new StringWriter();
            var writer = new IndentedTextWriter(stringStream, "\t");
            writer.WriteLine("// <auto-generated>");
            writer.WriteLine($"namespace {classExtensionInfo.ClassNamespace}");
            writer.WriteLine("{");
            writer.Indent++;
            bool isAbstract = classExtensionInfo.DeclarationSyntax.Modifiers.Any(
                SyntaxKind.AbstractKeyword
            );
            var accessibility = classExtensionInfo.DeclarationSyntax.Modifiers.FirstOrDefault(m =>
                m.Kind() == SyntaxKind.PublicKeyword
                || m.Kind() == SyntaxKind.InternalKeyword
                || m.Kind() == SyntaxKind.PrivateKeyword
            );
            writer.WriteLine(
                $"{accessibility}{(isAbstract ? SyntaxKind.AbstractKeyword : null)} partial class {classExtensionInfo.ClassName}"
            );
            writer.WriteLine($"{classExtensionInfo.DeclarationSyntax.TypeParameterList}");
            writer.WriteLine($"{classExtensionInfo.DeclarationSyntax.ConstraintClauses}");
            writer.WriteLine("{");
            writer.Indent++;
            foreach (var commandExtensionInfo in classExtensionInfo.CommandExtensionInfos)
            {
                var outputType = commandExtensionInfo.GetOutputTypeText();
                var inputType = commandExtensionInfo.GetInputTypeText();
                writer.WriteLine(
                    $"public ReactiveUI.ReactiveCommand<{inputType}, {outputType}> "
                        + $"{commandExtensionInfo.MethodName}Command {{ get; private set; }}"
                );
                var commandName = $"{commandExtensionInfo.MethodName}Command";
                if (
                    commandExtensionInfo.ReactiveCommandDatas.Any(d =>
                        d.Name == nameof(ReactiveCommandAttribute.CanExecute)
                    )
                )
                {
                    writer.WriteLine($"protected bool {commandName}CanExecute {{ get; set; }}");
                }
            }

            writer.WriteLine();
            if (classExtensionInfo.IsReactiveObjectXDerivedClass)
            {
                writer.WriteLine("protected override void InitializeCommands()");
            }
            else
            {
                writer.WriteLine("protected void InitializeCommands()");
            }
            writer.WriteLine("{");
            writer.Indent++;
            foreach (var commandExtensionInfo in classExtensionInfo.CommandExtensionInfos)
            {
                var commandName = $"{commandExtensionInfo.MethodName}Command";
                var outputType = commandExtensionInfo.GetOutputTypeText();
                var inputType = commandExtensionInfo.GetInputTypeText();

                writer.Write($"{commandName} = ReactiveUI.ReactiveCommand.");
                // 检测异步和参数
                if (commandExtensionInfo.ArgumentType is null)
                {
                    writer.Write(
                        commandExtensionInfo.IsTask is false
                            ? $"Create({commandExtensionInfo.MethodName}"
                            : $"CreateFromTask({commandExtensionInfo.MethodName}"
                    );
                }
                else if (commandExtensionInfo.MethodReturnType is not null)
                {
                    writer.Write(
                        commandExtensionInfo.IsTask is false
                            ? $"Create<{inputType}, {outputType}>({commandExtensionInfo.MethodName}"
                            : $"CreateFromTask<{inputType}, {outputType}>({commandExtensionInfo.MethodName}"
                    );
                }
                else if (commandExtensionInfo.MethodReturnType is null)
                {
                    writer.Write(
                        commandExtensionInfo.IsTask is false
                            ? $"Create<{inputType}>({commandExtensionInfo.MethodName}"
                            : $"CreateFromTask<{inputType}>({commandExtensionInfo.MethodName}"
                    );
                }
                if (
                    commandExtensionInfo.ReactiveCommandDatas.Any(d =>
                        d.Name == nameof(ReactiveCommandAttribute.CanExecute)
                    )
                )
                {
                    var canExecutePropertyName = $"{commandName}CanExecute";
                    writer.WriteLine(
                        $", ReactiveUI.WhenAnyMixin.WhenAnyValue(this, x => x.{canExecutePropertyName}));"
                    );
                }
                else
                    writer.WriteLine(");");
            }

            writer.Indent--;
            writer.WriteLine("}");

            writer.Indent--;
            writer.WriteLine("}");
            writer.Indent--;
            writer.WriteLine("}");

            context.AddSource(
                $"{classExtensionInfo.ClassName}.ReactiveCommand.g.cs",
                stringStream.ToString()
            );
            Console.Out.WriteLine(stringStream);
        }
    }

    private static IEnumerable<ClassExtensionInfo> ExtractMethodExtensionInfos(
        Compilation compilation
    )
    {
        foreach (var compilationSyntaxTree in compilation.SyntaxTrees)
        {
            var semanticModel = compilation.GetSemanticModel(compilationSyntaxTree);
            var declaredClasses = compilationSyntaxTree
                .GetRoot()
                .DescendantNodesAndSelf()
                .OfType<ClassDeclarationSyntax>();
            // 解析类
            foreach (var declaredClass in declaredClasses)
            {
                // 如果不是分布类型,则跳过
                if (declaredClass.Modifiers.Any(SyntaxKind.PartialKeyword) is false)
                    continue;

                var classSymbol = (INamedTypeSymbol)
                    ModelExtensions.GetDeclaredSymbol(semanticModel, declaredClass)!;

                var classNamespace = classSymbol.ContainingNamespace.ToString();
                var typeName = declaredClass.Identifier.ValueText;

                var classExtensionInfo = new ClassExtensionInfo
                {
                    ClassName = typeName,
                    ClassNamespace = classNamespace,
                    DeclarationSyntax = declaredClass,
                };
                // 遍历基类
                for (
                    var baseClassType = classSymbol.BaseType;
                    baseClassType is not null;
                    baseClassType = baseClassType.BaseType
                )
                {
                    // 如果基类为ReactiveObjectX
                    if (baseClassType.Name == "ReactiveObjectX")
                    {
                        classExtensionInfo.IsReactiveObjectXDerivedClass = true;
                        break;
                    }
                }
                // 通过MemberName在ClassDeclarationSyntax中获取MethodDeclarationSyntax
                // 解析方法
                var methodMembers = declaredClass.Members.OfType<MethodDeclarationSyntax>();
                foreach (var methodSyntax in methodMembers)
                {
                    var methodSymbol = (IMethodSymbol)
                        ModelExtensions.GetDeclaredSymbol(semanticModel, methodSyntax)!;
                    // 参数太多,跳过
                    if (methodSymbol.Parameters.Length > 1)
                        continue;
                    // 获取特性数据
                    var attributeData = methodSymbol
                        .GetAttributes()
                        .FirstOrDefault(a =>
                            a.AttributeClass?.Name == nameof(ReactiveCommandAttribute)
                        );
                    if (attributeData is null)
                        continue;
                    // 获取特性的参数

                    var reactiveCommandDatas = new List<ReactiveCommandData>();
                    TryGetAttributeAndValues(attributeData, semanticModel, out var values);
                    for (var i = 0; i < values.Count; i++)
                    {
                        var parameterName = values[i].Name;
                        if (values[i].Name == nameof(ReactiveCommandAttribute.CanExecute))
                        {
                            var memberName = values[i].Value.ToString();
                            declaredClass.Members.Any(m =>
                                m is MethodDeclarationSyntax p && p.Identifier.Text == memberName
                            );
                        }
                    }
                    // 是否为异步方法
                    bool isTask = IsTaskReturnType(methodSymbol.ReturnType);
                    var realReturnType = isTask
                        ? GetTaskReturnType(compilation, methodSymbol.ReturnType)
                        : methodSymbol.ReturnType;
                    // 是否为空返回值
                    var isReturnTypeVoid = SymbolEqualityComparer.Default.Equals(
                        realReturnType,
                        compilation.GetSpecialType(SpecialType.System_Void)
                    );

                    classExtensionInfo.CommandExtensionInfos.Add(
                        new()
                        {
                            MethodName = methodSymbol.Name,
                            MethodReturnType = isReturnTypeVoid ? null : realReturnType,
                            IsTask = isTask,
                            ArgumentType = methodSymbol.Parameters.SingleOrDefault()?.Type!,
                            ReactiveCommandDatas = reactiveCommandDatas
                        }
                    );
                }

                if (classExtensionInfo.CommandExtensionInfos.Any())
                    yield return classExtensionInfo;
            }
        }
    }

    public static bool TryGetAttributeAndValues(
        AttributeData attributeData,
        SemanticModel model,
        out List<NameTypeAndValue> attributeValues
    )
    {
        attributeValues = new();
        var constructorParams = attributeData.AttributeConstructor.Parameters;

        // Start with an indexed list of names for mandatory args

        var allArguments = attributeData
            .ConstructorArguments
            // For unnamed args, we get the name from the array we just made
            .Select((info, index) => (Name: constructorParams[index].Name, Constant: info))
            // Then we use name + value from the named values
            .Union(attributeData.NamedArguments.Select(x => (Name: x.Key, Constant: x.Value)))
            .Distinct();

        foreach (var argument in allArguments)
        {
            attributeValues.Add(
                new NameTypeAndValue(
                    name: argument.Name,
                    typeFullName: argument.Constant.Type.Name,
                    value: argument.Constant.Value
                )
            );
        }
        if (attributeValues.Count == 0)
            return false;
        return true;
    }

    private static ITypeSymbol GetTaskReturnType(Compilation compilation, ITypeSymbol typeSymbol)
    {
        if (typeSymbol is INamedTypeSymbol { TypeArguments.Length: 1 } namedTypeSymbol)
            return namedTypeSymbol.TypeArguments[0];
        return compilation.GetSpecialType(SpecialType.System_Void);
    }

    private static bool IsTaskReturnType(ITypeSymbol typeSymbol)
    {
        var nameFormat = SymbolDisplayFormat.FullyQualifiedFormat;
        do
        {
            var typeName = typeSymbol?.ToDisplayString(nameFormat);
            if (typeName == "global::System.Threading.Tasks.Task")
                return true;

            typeSymbol = typeSymbol?.BaseType;
        } while (typeSymbol is not null);

        return false;
    }
}

public class ReactiveCommandData : NameTypeAndValue
{
    public bool CanExecuteTargetIsMethod { get; set; }

    public ReactiveCommandData(string name, string typeFullName, object value)
        : base(name, typeFullName, value) { }
}

public class NameTypeAndValue
{
    public string Name { get; }
    public string TypeFullName { get; }
    public object Value { get; }

    public NameTypeAndValue(string name, string typeFullName, object value)
    {
        Name = name;
        TypeFullName = typeFullName;
        Value = value;
    }
}
